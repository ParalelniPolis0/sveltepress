// Vitest Snapshot v1

exports[`svelte compile > expansion 1`] = `
"/* generated by Svelte v3.55.0 */
import {
	SvelteComponent as SvelteComponent$,
	add_render_callback as add_render_callback$,
	append as append$,
	append_styles as append_styles$,
	attr as attr$,
	binding_callbacks as binding_callbacks$,
	check_outros as check_outros$,
	create_bidirectional_transition as create_bidirectional_transition$,
	create_component as create_component$,
	create_slot as create_slot$,
	destroy_component as destroy_component$,
	detach as detach$,
	element as element$,
	get_all_dirty_from_scope as get_all_dirty_from_scope$,
	get_slot_changes as get_slot_changes$,
	group_outros as group_outros$,
	init as init$,
	insert as insert$,
	listen as listen$,
	mount_component as mount_component$,
	null_to_empty as null_to_empty$,
	run_all as run_all$,
	safe_not_equal as safe_not_equal$,
	set_data as set_data$,
	space as space$,
	stop_propagation as stop_propagation$,
	text as text$,
	transition_in as transition_in$,
	transition_out as transition_out$,
	update_slot_base as update_slot_base$
} from \\"svelte/internal\\";

import { slide } from 'svelte/transition';
import { cubicInOut } from 'svelte/easing';
import Svelte from './icons/Svelte.svelte';
import SvelteWithColor from './icons/SvelteWithColor.svelte';
import ArrowDown from './icons/ArrowDown.svelte';

function add_css$(target) {
	append_styles$(target, \\"svelte-qzagc\\", \\".svp-live-code--container{--at-apply:mb-8 shadow-sm b-1 b-solid b-gray-2  dark:b-warmgray-8 rounded}.svp-live-code--demo{--at-apply:p-4}.c-expansion--body .svp-code-block{--at-apply:mb-none}.c-expansion--header.svelte-qzagc{--at-apply:rounded-b flex justify-between px-4 py-2 items-center}.c-expansion--icon.svelte-qzagc{--at-apply:mr-2 text-6 flex items-center}.c-expansion--arrow.svelte-qzagc{--at-apply:text-6 flex items-center}.c-expansion--header-left.svelte-qzagc{--at-apply:flex items-center}.c-expansion--title.svelte-qzagc{--at-apply:text-3.5}\\");
}

const get_arrow_slot_changes$ = dirty => ({});
const get_arrow_slot_context$ = ctx => ({});
const get_title_slot_changes$ = dirty => ({});
const get_title_slot_context$ = ctx => ({});
const get_icon_fold_slot_changes$ = dirty => ({});
const get_icon_fold_slot_context$ = ctx => ({});
const get_icon_expanded_slot_changes$ = dirty => ({});
const get_icon_expanded_slot_context$ = ctx => ({});

// (47:2) {#if reverse && expanded}
function create_if_block$_2(ctx) {
	let div$;
	let div$_transition$;
	let current;
	const default_slot_template$ = /*#slots*/ ctx[7].default;
	const default_slot$ = create_slot$(default_slot_template$, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div$ = element$(\\"div\\");
			if (default_slot$) default_slot$.c();
			attr$(div$, \\"class\\", \\"c-expansion--body\\");
		},
		m(target, anchor) {
			insert$(target, div$, anchor);

			if (default_slot$) {
				default_slot$.m(div$, null);
			}

			/*div$_binding$*/ ctx[8](div$);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot$) {
				if (default_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						default_slot$,
						default_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(default_slot_template$, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(default_slot$, local);

			add_render_callback$(() => {
				if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, { duration: 300, easing: cubicInOut }, true);
				div$_transition$.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out$(default_slot$, local);
			if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, { duration: 300, easing: cubicInOut }, false);
			div$_transition$.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach$(div$);
			if (default_slot$) default_slot$.d(detaching);
			/*div$_binding$*/ ctx[8](null);
			if (detaching && div$_transition$) div$_transition$.end();
		}
	};
}

// (76:10) {:else}
function create_else_block$(ctx) {
	let current;
	const icon_fold_slot_template$ = /*#slots*/ ctx[7][\\"icon-fold\\"];
	const icon_fold_slot$ = create_slot$(icon_fold_slot_template$, ctx, /*$$scope*/ ctx[6], get_icon_fold_slot_context$);
	const icon_fold_slot_or_fallback$ = icon_fold_slot$ || fallback_block$_3(ctx);

	return {
		c() {
			if (icon_fold_slot_or_fallback$) icon_fold_slot_or_fallback$.c();
		},
		m(target, anchor) {
			if (icon_fold_slot_or_fallback$) {
				icon_fold_slot_or_fallback$.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_fold_slot$) {
				if (icon_fold_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						icon_fold_slot$,
						icon_fold_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(icon_fold_slot_template$, /*$$scope*/ ctx[6], dirty, get_icon_fold_slot_changes$),
						get_icon_fold_slot_context$
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(icon_fold_slot_or_fallback$, local);
			current = true;
		},
		o(local) {
			transition_out$(icon_fold_slot_or_fallback$, local);
			current = false;
		},
		d(detaching) {
			if (icon_fold_slot_or_fallback$) icon_fold_slot_or_fallback$.d(detaching);
		}
	};
}

// (72:8) {#if expanded}
function create_if_block$_1(ctx) {
	let current;
	const icon_expanded_slot_template$ = /*#slots*/ ctx[7][\\"icon-expanded\\"];
	const icon_expanded_slot$ = create_slot$(icon_expanded_slot_template$, ctx, /*$$scope*/ ctx[6], get_icon_expanded_slot_context$);
	const icon_expanded_slot_or_fallback$ = icon_expanded_slot$ || fallback_block$_2(ctx);

	return {
		c() {
			if (icon_expanded_slot_or_fallback$) icon_expanded_slot_or_fallback$.c();
		},
		m(target, anchor) {
			if (icon_expanded_slot_or_fallback$) {
				icon_expanded_slot_or_fallback$.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_expanded_slot$) {
				if (icon_expanded_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						icon_expanded_slot$,
						icon_expanded_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(icon_expanded_slot_template$, /*$$scope*/ ctx[6], dirty, get_icon_expanded_slot_changes$),
						get_icon_expanded_slot_context$
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(icon_expanded_slot_or_fallback$, local);
			current = true;
		},
		o(local) {
			transition_out$(icon_expanded_slot_or_fallback$, local);
			current = false;
		},
		d(detaching) {
			if (icon_expanded_slot_or_fallback$) icon_expanded_slot_or_fallback$.d(detaching);
		}
	};
}

// (77:33)              
function fallback_block$_3(ctx) {
	let svelte$;
	let current;
	svelte$ = new Svelte({});

	return {
		c() {
			create_component$(svelte$.$$.fragment);
		},
		m(target, anchor) {
			mount_component$(svelte$, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$(svelte$.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$(svelte$.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$(svelte$, detaching);
		}
	};
}

// (73:37)              
function fallback_block$_2(ctx) {
	let sveltewithcolor$;
	let current;
	sveltewithcolor$ = new SvelteWithColor({});

	return {
		c() {
			create_component$(sveltewithcolor$.$$.fragment);
		},
		m(target, anchor) {
			mount_component$(sveltewithcolor$, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$(sveltewithcolor$.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$(sveltewithcolor$.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$(sveltewithcolor$, detaching);
		}
	};
}

// (84:27)            
function fallback_block$_1(ctx) {
	let t$;

	return {
		c() {
			t$ = text$(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert$(target, t$, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data$(t$, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach$(t$);
		}
	};
}

// (93:25)          
function fallback_block$(ctx) {
	let arrowdown$;
	let current;
	arrowdown$ = new ArrowDown({});

	return {
		c() {
			create_component$(arrowdown$.$$.fragment);
		},
		m(target, anchor) {
			mount_component$(arrowdown$, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$(arrowdown$.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$(arrowdown$.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$(arrowdown$, detaching);
		}
	};
}

// (98:2) {#if !reverse && expanded}
function create_if_block$(ctx) {
	let div$;
	let div$_transition$;
	let current;
	const default_slot_template$ = /*#slots*/ ctx[7].default;
	const default_slot$ = create_slot$(default_slot_template$, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div$ = element$(\\"div\\");
			if (default_slot$) default_slot$.c();
			attr$(div$, \\"class\\", \\"c-expansion--body\\");
		},
		m(target, anchor) {
			insert$(target, div$, anchor);

			if (default_slot$) {
				default_slot$.m(div$, null);
			}

			/*div$_binding$_1*/ ctx[9](div$);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot$) {
				if (default_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						default_slot$,
						default_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(default_slot_template$, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(default_slot$, local);

			add_render_callback$(() => {
				if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, {}, true);
				div$_transition$.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out$(default_slot$, local);
			if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, {}, false);
			div$_transition$.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach$(div$);
			if (default_slot$) default_slot$.d(detaching);
			/*div$_binding$_1*/ ctx[9](null);
			if (detaching && div$_transition$) div$_transition$.end();
		}
	};
}

function create_fragment(ctx) {
	let div5$;
	let t0$;
	let div4$;
	let div2$;
	let div0$;
	let current_block_type_index$;
	let if_block1$;
	let t1$;
	let div1$;
	let t2$;
	let div3$;
	let div3$_class_value$;
	let t3$;
	let div5$_class_value$;
	let current;
	let mounted;
	let dispose;
	let if_block0$ = /*reverse*/ ctx[2] && /*expanded*/ ctx[0] && create_if_block$_2(ctx);
	const if_block_creators$ = [create_if_block$_1, create_else_block$];
	const if_blocks$ = [];

	function select_block_type$(ctx, dirty) {
		if (/*expanded*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index$ = select_block_type$(ctx, -1);
	if_block1$ = if_blocks$[current_block_type_index$] = if_block_creators$[current_block_type_index$](ctx);
	const title_slot_template$ = /*#slots*/ ctx[7].title;
	const title_slot$ = create_slot$(title_slot_template$, ctx, /*$$scope*/ ctx[6], get_title_slot_context$);
	const title_slot_or_fallback$ = title_slot$ || fallback_block$_1(ctx);
	const arrow_slot_template$ = /*#slots*/ ctx[7].arrow;
	const arrow_slot$ = create_slot$(arrow_slot_template$, ctx, /*$$scope*/ ctx[6], get_arrow_slot_context$);
	const arrow_slot_or_fallback$ = arrow_slot$ || fallback_block$(ctx);
	let if_block2$ = !/*reverse*/ ctx[2] && /*expanded*/ ctx[0] && create_if_block$(ctx);

	return {
		c() {
			div5$ = element$(\\"div\\");
			if (if_block0$) if_block0$.c();
			t0$ = space$();
			div4$ = element$(\\"div\\");
			div2$ = element$(\\"div\\");
			div0$ = element$(\\"div\\");
			if_block1$.c();
			t1$ = space$();
			div1$ = element$(\\"div\\");
			if (title_slot_or_fallback$) title_slot_or_fallback$.c();
			t2$ = space$();
			div3$ = element$(\\"div\\");
			if (arrow_slot_or_fallback$) arrow_slot_or_fallback$.c();
			t3$ = space$();
			if (if_block2$) if_block2$.c();
			attr$(div0$, \\"class\\", \\"c-expansion--icon svelte-qzagc\\");
			attr$(div1$, \\"class\\", \\"c-expansion--title svelte-qzagc\\");
			attr$(div2$, \\"class\\", \\"c-expansion--header-left svelte-qzagc\\");
			attr$(div3$, \\"class\\", div3$_class_value$ = \\"\\" + (null_to_empty$(\`c-expansion--arrow \${/*expanded*/ ctx[0] ? 'c-expansion--arrow-expanded' : ''}\`) + \\" svelte-qzagc\\"));
			attr$(div4$, \\"class\\", \\"c-expansion--header svelte-qzagc\\");
			attr$(div4$, \\"style\\", /*headerStyle*/ ctx[3]);
			attr$(div5$, \\"class\\", div5$_class_value$ = \\"\\" + (null_to_empty$(\`c-expansion \${/*expanded*/ ctx[0] ? 'c-expansion--expanded' : ''}\`) + \\" svelte-qzagc\\"));
		},
		m(target, anchor) {
			insert$(target, div5$, anchor);
			if (if_block0$) if_block0$.m(div5$, null);
			append$(div5$, t0$);
			append$(div5$, div4$);
			append$(div4$, div2$);
			append$(div2$, div0$);
			if_blocks$[current_block_type_index$].m(div0$, null);
			append$(div2$, t1$);
			append$(div2$, div1$);

			if (title_slot_or_fallback$) {
				title_slot_or_fallback$.m(div1$, null);
			}

			append$(div4$, t2$);
			append$(div4$, div3$);

			if (arrow_slot_or_fallback$) {
				arrow_slot_or_fallback$.m(div3$, null);
			}

			append$(div5$, t3$);
			if (if_block2$) if_block2$.m(div5$, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen$(div4$, \\"click\\", stop_propagation$(/*onHeaderClick*/ ctx[5])),
					listen$(div4$, \\"keypress\\", /*onHeaderClick*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*reverse*/ ctx[2] && /*expanded*/ ctx[0]) {
				if (if_block0$) {
					if_block0$.p(ctx, dirty);

					if (dirty & /*reverse, expanded*/ 5) {
						transition_in$(if_block0$, 1);
					}
				} else {
					if_block0$ = create_if_block$_2(ctx);
					if_block0$.c();
					transition_in$(if_block0$, 1);
					if_block0$.m(div5$, t0$);
				}
			} else if (if_block0$) {
				group_outros$();

				transition_out$(if_block0$, 1, 1, () => {
					if_block0$ = null;
				});

				check_outros$();
			}

			let previous_block_index$ = current_block_type_index$;
			current_block_type_index$ = select_block_type$(ctx, dirty);

			if (current_block_type_index$ === previous_block_index$) {
				if_blocks$[current_block_type_index$].p(ctx, dirty);
			} else {
				group_outros$();

				transition_out$(if_blocks$[previous_block_index$], 1, 1, () => {
					if_blocks$[previous_block_index$] = null;
				});

				check_outros$();
				if_block1$ = if_blocks$[current_block_type_index$];

				if (!if_block1$) {
					if_block1$ = if_blocks$[current_block_type_index$] = if_block_creators$[current_block_type_index$](ctx);
					if_block1$.c();
				} else {
					if_block1$.p(ctx, dirty);
				}

				transition_in$(if_block1$, 1);
				if_block1$.m(div0$, null);
			}

			if (title_slot$) {
				if (title_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						title_slot$,
						title_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(title_slot_template$, /*$$scope*/ ctx[6], dirty, get_title_slot_changes$),
						get_title_slot_context$
					);
				}
			} else {
				if (title_slot_or_fallback$ && title_slot_or_fallback$.p && (!current || dirty & /*title*/ 2)) {
					title_slot_or_fallback$.p(ctx, !current ? -1 : dirty);
				}
			}

			if (arrow_slot$) {
				if (arrow_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						arrow_slot$,
						arrow_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(arrow_slot_template$, /*$$scope*/ ctx[6], dirty, get_arrow_slot_changes$),
						get_arrow_slot_context$
					);
				}
			}

			if (!current || dirty & /*expanded*/ 1 && div3$_class_value$ !== (div3$_class_value$ = \\"\\" + (null_to_empty$(\`c-expansion--arrow \${/*expanded*/ ctx[0] ? 'c-expansion--arrow-expanded' : ''}\`) + \\" svelte-qzagc\\"))) {
				attr$(div3$, \\"class\\", div3$_class_value$);
			}

			if (!current || dirty & /*headerStyle*/ 8) {
				attr$(div4$, \\"style\\", /*headerStyle*/ ctx[3]);
			}

			if (!/*reverse*/ ctx[2] && /*expanded*/ ctx[0]) {
				if (if_block2$) {
					if_block2$.p(ctx, dirty);

					if (dirty & /*reverse, expanded*/ 5) {
						transition_in$(if_block2$, 1);
					}
				} else {
					if_block2$ = create_if_block$(ctx);
					if_block2$.c();
					transition_in$(if_block2$, 1);
					if_block2$.m(div5$, null);
				}
			} else if (if_block2$) {
				group_outros$();

				transition_out$(if_block2$, 1, 1, () => {
					if_block2$ = null;
				});

				check_outros$();
			}

			if (!current || dirty & /*expanded*/ 1 && div5$_class_value$ !== (div5$_class_value$ = \\"\\" + (null_to_empty$(\`c-expansion \${/*expanded*/ ctx[0] ? 'c-expansion--expanded' : ''}\`) + \\" svelte-qzagc\\"))) {
				attr$(div5$, \\"class\\", div5$_class_value$);
			}
		},
		i(local) {
			if (current) return;
			transition_in$(if_block0$);
			transition_in$(if_block1$);
			transition_in$(title_slot_or_fallback$, local);
			transition_in$(arrow_slot_or_fallback$, local);
			transition_in$(if_block2$);
			current = true;
		},
		o(local) {
			transition_out$(if_block0$);
			transition_out$(if_block1$);
			transition_out$(title_slot_or_fallback$, local);
			transition_out$(arrow_slot_or_fallback$, local);
			transition_out$(if_block2$);
			current = false;
		},
		d(detaching) {
			if (detaching) detach$(div5$);
			if (if_block0$) if_block0$.d();
			if_blocks$[current_block_type_index$].d();
			if (title_slot_or_fallback$) title_slot_or_fallback$.d(detaching);
			if (arrow_slot_or_fallback$) arrow_slot_or_fallback$.d(detaching);
			if (if_block2$) if_block2$.d();
			mounted = false;
			run_all$(dispose);
		}
	};
}

function instance$($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title = '' } = $$props;
	let { expanded = false } = $$props;
	let { reverse = false } = $$props;
	let { headerStyle = '' } = $$props;

	/**
 * The panel body dom
 * @type {HTMLDivElement}
 */
	let bodyDom;

	function onHeaderClick() {
		$$invalidate(0, expanded = !expanded);
	}

	function div$_binding$($$value) {
		binding_callbacks$[$$value ? 'unshift' : 'push'](() => {
			bodyDom = $$value;
			$$invalidate(4, bodyDom);
		});
	}

	function div$_binding$_1($$value) {
		binding_callbacks$[$$value ? 'unshift' : 'push'](() => {
			bodyDom = $$value;
			$$invalidate(4, bodyDom);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('expanded' in $$props) $$invalidate(0, expanded = $$props.expanded);
		if ('reverse' in $$props) $$invalidate(2, reverse = $$props.reverse);
		if ('headerStyle' in $$props) $$invalidate(3, headerStyle = $$props.headerStyle);
		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		expanded,
		title,
		reverse,
		headerStyle,
		bodyDom,
		onHeaderClick,
		$$scope,
		slots,
		div$_binding$,
		div$_binding$_1
	];
}

class Component$ extends SvelteComponent$ {
	constructor(options) {
		super();

		init$(
			this,
			options,
			instance$,
			create_fragment,
			safe_not_equal$,
			{
				title: 1,
				expanded: 0,
				reverse: 2,
				headerStyle: 3
			},
			add_css$
		);
	}
}

export default Component$;"
`;
