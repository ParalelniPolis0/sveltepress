// Vitest Snapshot v1

exports[`live code > simple parse 1`] = `
"<script context=\\"module\\">
import CExpansion from '@svelte-press/theme-default/CExpansion.svelte'
import LiveCodea0d9514c47e from '/Users/dongsheng/Documents/@dongsheng/sveltepress/packages/theme-default/.sveltepress/live-code/LiveCodea0d9514c47e.svelte'
  const a = 'a'
  export const b = 'b'
</script>
<script>
  import Foo from '/path/to/Foo.svelte'
</script>

<h3>title level 3</h3>
<Foo />
<div class=\\"mb-8 shadow-sm\\"><div class=\\"bg-white dark:bg-warmgray-8 rounded-t p-4 b-t-1 b-x-1 b-gray-2 dark:b-warmgray-9 b-t-solid b-x-solid\\"><LiveCodea0d9514c47e /></div><CExpansion title=\\"Click fold/expand code\\" reverse={true}><pre class=\\"language-svelte\\">{@html \`<code class=\\"language-svelte\\"><span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>script</span><span class=\\"token punctuation\\">></span></span><span class=\\"token script\\"><span class=\\"token language-javascript\\">
  <span class=\\"token keyword\\">let</span> count <span class=\\"token operator\\">=</span> <span class=\\"token number\\">1</span>
</span></span><span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;/</span>script</span><span class=\\"token punctuation\\">></span></span>

<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>button</span> <span class=\\"token attr-name\\"><span class=\\"token namespace\\">on:</span>click=</span><span class=\\"token language-javascript\\"><span class=\\"token punctuation\\">&#123;</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=></span> count<span class=\\"token operator\\">++</span><span class=\\"token punctuation\\">&#125;</span></span><span class=\\"token punctuation\\">></span></span>
  You've clicked <span class=\\"token language-javascript\\"><span class=\\"token punctuation\\">&#123;</span>count<span class=\\"token punctuation\\">&#125;</span></span> times
<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;/</span>button</span><span class=\\"token punctuation\\">></span></span></code>\`}</pre></CExpansion></div>
"
`;

exports[`svelte compile > expansion 1`] = `
{
  "code": "/* generated by Svelte v3.55.0 */
import {
	SvelteComponent as SvelteComponent$,
	add_render_callback as add_render_callback$,
	append as append$,
	attr as attr$,
	binding_callbacks as binding_callbacks$,
	check_outros as check_outros$,
	create_bidirectional_transition as create_bidirectional_transition$,
	create_component as create_component$,
	create_slot as create_slot$,
	destroy_component as destroy_component$,
	detach as detach$,
	element as element$,
	get_all_dirty_from_scope as get_all_dirty_from_scope$,
	get_slot_changes as get_slot_changes$,
	group_outros as group_outros$,
	init as init$,
	insert as insert$,
	listen as listen$,
	mount_component as mount_component$,
	run_all as run_all$,
	safe_not_equal as safe_not_equal$,
	set_data as set_data$,
	space as space$,
	stop_propagation as stop_propagation$,
	text as text$,
	transition_in as transition_in$,
	transition_out as transition_out$,
	update_slot_base as update_slot_base$
} from \\"svelte/internal\\";

import { slide } from 'svelte/transition';
import { cubicInOut } from 'svelte/easing';
import Svelte from './icons/Svelte.svelte';
import SvelteWithColor from './icons/SvelteWithColor.svelte';
import ArrowDown from './icons/ArrowDown.svelte';
const get_arrow_slot_changes$ = dirty => ({});
const get_arrow_slot_context$ = ctx => ({});
const get_title_slot_changes$ = dirty => ({});
const get_title_slot_context$ = ctx => ({});
const get_icon_fold_slot_changes$ = dirty => ({});
const get_icon_fold_slot_context$ = ctx => ({});
const get_icon_expanded_slot_changes$ = dirty => ({});
const get_icon_expanded_slot_context$ = ctx => ({});

// (47:2) {#if reverse && expanded}
function create_if_block$_2(ctx) {
	let div$;
	let div$_transition$;
	let current;
	const default_slot_template$ = /*#slots*/ ctx[7].default;
	const default_slot$ = create_slot$(default_slot_template$, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div$ = element$(\\"div\\");
			if (default_slot$) default_slot$.c();
			attr$(div$, \\"class\\", \\"c-expansion--body\\");
		},
		m(target, anchor) {
			insert$(target, div$, anchor);

			if (default_slot$) {
				default_slot$.m(div$, null);
			}

			/*div$_binding$*/ ctx[8](div$);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot$) {
				if (default_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						default_slot$,
						default_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(default_slot_template$, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(default_slot$, local);

			add_render_callback$(() => {
				if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, { duration: 300, easing: cubicInOut }, true);
				div$_transition$.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out$(default_slot$, local);
			if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, { duration: 300, easing: cubicInOut }, false);
			div$_transition$.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach$(div$);
			if (default_slot$) default_slot$.d(detaching);
			/*div$_binding$*/ ctx[8](null);
			if (detaching && div$_transition$) div$_transition$.end();
		}
	};
}

// (76:10) {:else}
function create_else_block$(ctx) {
	let current;
	const icon_fold_slot_template$ = /*#slots*/ ctx[7][\\"icon-fold\\"];
	const icon_fold_slot$ = create_slot$(icon_fold_slot_template$, ctx, /*$$scope*/ ctx[6], get_icon_fold_slot_context$);
	const icon_fold_slot_or_fallback$ = icon_fold_slot$ || fallback_block$_3(ctx);

	return {
		c() {
			if (icon_fold_slot_or_fallback$) icon_fold_slot_or_fallback$.c();
		},
		m(target, anchor) {
			if (icon_fold_slot_or_fallback$) {
				icon_fold_slot_or_fallback$.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_fold_slot$) {
				if (icon_fold_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						icon_fold_slot$,
						icon_fold_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(icon_fold_slot_template$, /*$$scope*/ ctx[6], dirty, get_icon_fold_slot_changes$),
						get_icon_fold_slot_context$
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(icon_fold_slot_or_fallback$, local);
			current = true;
		},
		o(local) {
			transition_out$(icon_fold_slot_or_fallback$, local);
			current = false;
		},
		d(detaching) {
			if (icon_fold_slot_or_fallback$) icon_fold_slot_or_fallback$.d(detaching);
		}
	};
}

// (72:8) {#if expanded}
function create_if_block$_1(ctx) {
	let current;
	const icon_expanded_slot_template$ = /*#slots*/ ctx[7][\\"icon-expanded\\"];
	const icon_expanded_slot$ = create_slot$(icon_expanded_slot_template$, ctx, /*$$scope*/ ctx[6], get_icon_expanded_slot_context$);
	const icon_expanded_slot_or_fallback$ = icon_expanded_slot$ || fallback_block$_2(ctx);

	return {
		c() {
			if (icon_expanded_slot_or_fallback$) icon_expanded_slot_or_fallback$.c();
		},
		m(target, anchor) {
			if (icon_expanded_slot_or_fallback$) {
				icon_expanded_slot_or_fallback$.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_expanded_slot$) {
				if (icon_expanded_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						icon_expanded_slot$,
						icon_expanded_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(icon_expanded_slot_template$, /*$$scope*/ ctx[6], dirty, get_icon_expanded_slot_changes$),
						get_icon_expanded_slot_context$
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(icon_expanded_slot_or_fallback$, local);
			current = true;
		},
		o(local) {
			transition_out$(icon_expanded_slot_or_fallback$, local);
			current = false;
		},
		d(detaching) {
			if (icon_expanded_slot_or_fallback$) icon_expanded_slot_or_fallback$.d(detaching);
		}
	};
}

// (77:33)              
function fallback_block$_3(ctx) {
	let svelte$;
	let current;
	svelte$ = new Svelte({});

	return {
		c() {
			create_component$(svelte$.$$.fragment);
		},
		m(target, anchor) {
			mount_component$(svelte$, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$(svelte$.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$(svelte$.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$(svelte$, detaching);
		}
	};
}

// (73:37)              
function fallback_block$_2(ctx) {
	let sveltewithcolor$;
	let current;
	sveltewithcolor$ = new SvelteWithColor({});

	return {
		c() {
			create_component$(sveltewithcolor$.$$.fragment);
		},
		m(target, anchor) {
			mount_component$(sveltewithcolor$, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$(sveltewithcolor$.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$(sveltewithcolor$.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$(sveltewithcolor$, detaching);
		}
	};
}

// (84:27)            
function fallback_block$_1(ctx) {
	let t$;

	return {
		c() {
			t$ = text$(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert$(target, t$, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data$(t$, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach$(t$);
		}
	};
}

// (93:25)          
function fallback_block$(ctx) {
	let arrowdown$;
	let current;
	arrowdown$ = new ArrowDown({});

	return {
		c() {
			create_component$(arrowdown$.$$.fragment);
		},
		m(target, anchor) {
			mount_component$(arrowdown$, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$(arrowdown$.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$(arrowdown$.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$(arrowdown$, detaching);
		}
	};
}

// (98:2) {#if !reverse && expanded}
function create_if_block$(ctx) {
	let div$;
	let div$_transition$;
	let current;
	const default_slot_template$ = /*#slots*/ ctx[7].default;
	const default_slot$ = create_slot$(default_slot_template$, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div$ = element$(\\"div\\");
			if (default_slot$) default_slot$.c();
			attr$(div$, \\"class\\", \\"c-expansion--body\\");
		},
		m(target, anchor) {
			insert$(target, div$, anchor);

			if (default_slot$) {
				default_slot$.m(div$, null);
			}

			/*div$_binding$_1*/ ctx[9](div$);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot$) {
				if (default_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						default_slot$,
						default_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(default_slot_template$, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in$(default_slot$, local);

			add_render_callback$(() => {
				if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, {}, true);
				div$_transition$.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out$(default_slot$, local);
			if (!div$_transition$) div$_transition$ = create_bidirectional_transition$(div$, slide, {}, false);
			div$_transition$.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach$(div$);
			if (default_slot$) default_slot$.d(detaching);
			/*div$_binding$_1*/ ctx[9](null);
			if (detaching && div$_transition$) div$_transition$.end();
		}
	};
}

function create_fragment(ctx) {
	let div5$;
	let t0$;
	let div4$;
	let div2$;
	let div0$;
	let current_block_type_index$;
	let if_block1$;
	let t1$;
	let div1$;
	let t2$;
	let div3$;
	let div3$_class_value$;
	let t3$;
	let div5$_class_value$;
	let current;
	let mounted;
	let dispose;
	let if_block0$ = /*reverse*/ ctx[2] && /*expanded*/ ctx[0] && create_if_block$_2(ctx);
	const if_block_creators$ = [create_if_block$_1, create_else_block$];
	const if_blocks$ = [];

	function select_block_type$(ctx, dirty) {
		if (/*expanded*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index$ = select_block_type$(ctx, -1);
	if_block1$ = if_blocks$[current_block_type_index$] = if_block_creators$[current_block_type_index$](ctx);
	const title_slot_template$ = /*#slots*/ ctx[7].title;
	const title_slot$ = create_slot$(title_slot_template$, ctx, /*$$scope*/ ctx[6], get_title_slot_context$);
	const title_slot_or_fallback$ = title_slot$ || fallback_block$_1(ctx);
	const arrow_slot_template$ = /*#slots*/ ctx[7].arrow;
	const arrow_slot$ = create_slot$(arrow_slot_template$, ctx, /*$$scope*/ ctx[6], get_arrow_slot_context$);
	const arrow_slot_or_fallback$ = arrow_slot$ || fallback_block$(ctx);
	let if_block2$ = !/*reverse*/ ctx[2] && /*expanded*/ ctx[0] && create_if_block$(ctx);

	return {
		c() {
			div5$ = element$(\\"div\\");
			if (if_block0$) if_block0$.c();
			t0$ = space$();
			div4$ = element$(\\"div\\");
			div2$ = element$(\\"div\\");
			div0$ = element$(\\"div\\");
			if_block1$.c();
			t1$ = space$();
			div1$ = element$(\\"div\\");
			if (title_slot_or_fallback$) title_slot_or_fallback$.c();
			t2$ = space$();
			div3$ = element$(\\"div\\");
			if (arrow_slot_or_fallback$) arrow_slot_or_fallback$.c();
			t3$ = space$();
			if (if_block2$) if_block2$.c();
			attr$(div0$, \\"class\\", \\"c-expansion--icon mr-2 text-6 flex items-center\\");
			attr$(div1$, \\"class\\", \\"c-expansion--title text-3.5\\");
			attr$(div2$, \\"class\\", \\"flex items-center\\");
			attr$(div3$, \\"class\\", div3$_class_value$ = \`c-expansion--arrow \${/*expanded*/ ctx[0] ? 'c-expansion--arrow-expanded' : ''} text-6 flex items-center\`);
			attr$(div4$, \\"class\\", \\"c-expansion--header rounded-b flex justify-between px-4 py-2 items-center\\");
			attr$(div4$, \\"style\\", /*headerStyle*/ ctx[3]);
			attr$(div5$, \\"class\\", div5$_class_value$ = \`c-expansion \${/*expanded*/ ctx[0] ? 'c-expansion--expanded' : ''}\`);
		},
		m(target, anchor) {
			insert$(target, div5$, anchor);
			if (if_block0$) if_block0$.m(div5$, null);
			append$(div5$, t0$);
			append$(div5$, div4$);
			append$(div4$, div2$);
			append$(div2$, div0$);
			if_blocks$[current_block_type_index$].m(div0$, null);
			append$(div2$, t1$);
			append$(div2$, div1$);

			if (title_slot_or_fallback$) {
				title_slot_or_fallback$.m(div1$, null);
			}

			append$(div4$, t2$);
			append$(div4$, div3$);

			if (arrow_slot_or_fallback$) {
				arrow_slot_or_fallback$.m(div3$, null);
			}

			append$(div5$, t3$);
			if (if_block2$) if_block2$.m(div5$, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen$(div4$, \\"click\\", stop_propagation$(/*onHeaderClick*/ ctx[5])),
					listen$(div4$, \\"keypress\\", /*onHeaderClick*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*reverse*/ ctx[2] && /*expanded*/ ctx[0]) {
				if (if_block0$) {
					if_block0$.p(ctx, dirty);

					if (dirty & /*reverse, expanded*/ 5) {
						transition_in$(if_block0$, 1);
					}
				} else {
					if_block0$ = create_if_block$_2(ctx);
					if_block0$.c();
					transition_in$(if_block0$, 1);
					if_block0$.m(div5$, t0$);
				}
			} else if (if_block0$) {
				group_outros$();

				transition_out$(if_block0$, 1, 1, () => {
					if_block0$ = null;
				});

				check_outros$();
			}

			let previous_block_index$ = current_block_type_index$;
			current_block_type_index$ = select_block_type$(ctx, dirty);

			if (current_block_type_index$ === previous_block_index$) {
				if_blocks$[current_block_type_index$].p(ctx, dirty);
			} else {
				group_outros$();

				transition_out$(if_blocks$[previous_block_index$], 1, 1, () => {
					if_blocks$[previous_block_index$] = null;
				});

				check_outros$();
				if_block1$ = if_blocks$[current_block_type_index$];

				if (!if_block1$) {
					if_block1$ = if_blocks$[current_block_type_index$] = if_block_creators$[current_block_type_index$](ctx);
					if_block1$.c();
				} else {
					if_block1$.p(ctx, dirty);
				}

				transition_in$(if_block1$, 1);
				if_block1$.m(div0$, null);
			}

			if (title_slot$) {
				if (title_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						title_slot$,
						title_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(title_slot_template$, /*$$scope*/ ctx[6], dirty, get_title_slot_changes$),
						get_title_slot_context$
					);
				}
			} else {
				if (title_slot_or_fallback$ && title_slot_or_fallback$.p && (!current || dirty & /*title*/ 2)) {
					title_slot_or_fallback$.p(ctx, !current ? -1 : dirty);
				}
			}

			if (arrow_slot$) {
				if (arrow_slot$.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base$(
						arrow_slot$,
						arrow_slot_template$,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope$(/*$$scope*/ ctx[6])
						: get_slot_changes$(arrow_slot_template$, /*$$scope*/ ctx[6], dirty, get_arrow_slot_changes$),
						get_arrow_slot_context$
					);
				}
			}

			if (!current || dirty & /*expanded*/ 1 && div3$_class_value$ !== (div3$_class_value$ = \`c-expansion--arrow \${/*expanded*/ ctx[0] ? 'c-expansion--arrow-expanded' : ''} text-6 flex items-center\`)) {
				attr$(div3$, \\"class\\", div3$_class_value$);
			}

			if (!current || dirty & /*headerStyle*/ 8) {
				attr$(div4$, \\"style\\", /*headerStyle*/ ctx[3]);
			}

			if (!/*reverse*/ ctx[2] && /*expanded*/ ctx[0]) {
				if (if_block2$) {
					if_block2$.p(ctx, dirty);

					if (dirty & /*reverse, expanded*/ 5) {
						transition_in$(if_block2$, 1);
					}
				} else {
					if_block2$ = create_if_block$(ctx);
					if_block2$.c();
					transition_in$(if_block2$, 1);
					if_block2$.m(div5$, null);
				}
			} else if (if_block2$) {
				group_outros$();

				transition_out$(if_block2$, 1, 1, () => {
					if_block2$ = null;
				});

				check_outros$();
			}

			if (!current || dirty & /*expanded*/ 1 && div5$_class_value$ !== (div5$_class_value$ = \`c-expansion \${/*expanded*/ ctx[0] ? 'c-expansion--expanded' : ''}\`)) {
				attr$(div5$, \\"class\\", div5$_class_value$);
			}
		},
		i(local) {
			if (current) return;
			transition_in$(if_block0$);
			transition_in$(if_block1$);
			transition_in$(title_slot_or_fallback$, local);
			transition_in$(arrow_slot_or_fallback$, local);
			transition_in$(if_block2$);
			current = true;
		},
		o(local) {
			transition_out$(if_block0$);
			transition_out$(if_block1$);
			transition_out$(title_slot_or_fallback$, local);
			transition_out$(arrow_slot_or_fallback$, local);
			transition_out$(if_block2$);
			current = false;
		},
		d(detaching) {
			if (detaching) detach$(div5$);
			if (if_block0$) if_block0$.d();
			if_blocks$[current_block_type_index$].d();
			if (title_slot_or_fallback$) title_slot_or_fallback$.d(detaching);
			if (arrow_slot_or_fallback$) arrow_slot_or_fallback$.d(detaching);
			if (if_block2$) if_block2$.d();
			mounted = false;
			run_all$(dispose);
		}
	};
}

function instance$($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title = '' } = $$props;
	let { expanded = false } = $$props;
	let { reverse = false } = $$props;
	let { headerStyle = '' } = $$props;

	/**
 * The panel body dom
 * @type {HTMLDivElement}
 */
	let bodyDom;

	function onHeaderClick() {
		$$invalidate(0, expanded = !expanded);
	}

	function div$_binding$($$value) {
		binding_callbacks$[$$value ? 'unshift' : 'push'](() => {
			bodyDom = $$value;
			$$invalidate(4, bodyDom);
		});
	}

	function div$_binding$_1($$value) {
		binding_callbacks$[$$value ? 'unshift' : 'push'](() => {
			bodyDom = $$value;
			$$invalidate(4, bodyDom);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('expanded' in $$props) $$invalidate(0, expanded = $$props.expanded);
		if ('reverse' in $$props) $$invalidate(2, reverse = $$props.reverse);
		if ('headerStyle' in $$props) $$invalidate(3, headerStyle = $$props.headerStyle);
		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		expanded,
		title,
		reverse,
		headerStyle,
		bodyDom,
		onHeaderClick,
		$$scope,
		slots,
		div$_binding$,
		div$_binding$_1
	];
}

class Component$ extends SvelteComponent$ {
	constructor(options) {
		super();

		init$(this, options, instance$, create_fragment, safe_not_equal$, {
			title: 1,
			expanded: 0,
			reverse: 2,
			headerStyle: 3
		});
	}
}

export default Component$;",
  "map": {
    "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SACW,KAAK,QAAQ,mBAAmB;SAChC,UAAU,QAAQ,eAAe;OACnC,MAAM,MAAM,uBAAuB;OACnC,eAAe,MAAM,gCAAgC;OACrD,SAAS,MAAM,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;GA0C9C,OAYM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8FAVF,QAAQ,EAAE,GAAG,EACb,MAAM,EAAE,UAAU;;;;;;;;6FADlB,QAAQ,EAAE,GAAG,EACb,MAAM,EAAE,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAkCf,GAAK;;;;;;oDAAL,GAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAcZ,OASM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BA7DH,GAAO,oBAAI,GAAQ;;;;;mBAyBb,GAAQ;;;;;;;;;;;;+BA0Bb,GAAO,oBAAI,GAAQ;;;;;;;;;;;;;;;;;;;;;;iFARQ,GAAQ,MAAG,6BAA6B,GAAG,EAAE;;yCAzBrE,GAAW;0EApBE,GAAQ,MAAG,uBAAuB,GAAG,EAAE;;;GAD/D,OAkEM;;;GA/CJ,OAkCM;GA5BJ,OAmBM;GAlBJ,OAWM;;;GACN,OAKM;;;;;;;GAER,OAOM;;;;;;;;;;;;iEA9BoB,GAAa;kDAC1B,GAAa;;;;;;;mBApBvB,GAAO,oBAAI,GAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6HA2CS,GAAQ,MAAG,6BAA6B,GAAG,EAAE;;;;;0CAzBrE,GAAW;;;oBAiCd,GAAO,oBAAI,GAAQ;;;;;;;;;;;;;;;;;;;;;;;sHArDH,GAAQ,MAAG,uBAAuB,GAAG,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAjClD,KAAK,GAAG,EAAE;OAMV,QAAQ,GAAG,KAAK;OAMhB,OAAO,GAAG,KAAK;OAMf,WAAW,GAAG,EAAE;;;;;;KAMvB,OAAO;;UAEF,aAAa;kBACpB,QAAQ,IAAI,QAAQ;;;;;GAcP,OAAO;;;;;;;GAgDP,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",
    "names": [],
    "sources": [
      null,
    ],
    "sourcesContent": [
      "<script>
  import { slide } from 'svelte/transition'
  import { cubicInOut } from 'svelte/easing'
  import Svelte from './icons/Svelte.svelte'
  import SvelteWithColor from './icons/SvelteWithColor.svelte'
  import ArrowDown from './icons/ArrowDown.svelte'

  /**
   * The title of the expansion
   * @type {string}
   */
  export let title = ''

  /**
   * Determine whether the expansion is expanded or not. It is recomended to use \`bind:expanded\`
   * @type {boolean}
   */
  export let expanded = false

  /**
   * Determine the expand direction, \`false\` means down, \`true\` means up
   * @type {boolean}
   */
  export let reverse = false

  /**
   * Custom header style
   * @type {string}
   */
  export let headerStyle = ''

  /**
   * The panel body dom
   * @type {HTMLDivElement}
   */
  let bodyDom

  function onHeaderClick() {
    expanded = !expanded
  }

</script>

<div
  class={\`c-expansion \${expanded ? 'c-expansion--expanded' : ''}\`}
>
  {#if reverse && expanded}
    <div
      transition:slide={{
        duration: 300,
        easing: cubicInOut,
      }}
      bind:this={bodyDom}
      class=\\"c-expansion--body\\"
    >
      <!--  
        Expansion body content 
      -->
      <slot />
    </div>
  {/if}
  <!-- The header click function, emit the expand status exchange -->
  <div
    class=\\"c-expansion--header rounded-b flex justify-between px-4 py-2 items-center\\"
    style={headerStyle}
    on:click|stopPropagation={onHeaderClick}
    on:keypress={onHeaderClick}
  >
    <div class=\\"flex items-center\\">
      <div class=\\"c-expansion--icon mr-2 text-6 flex items-center\\">
        <!-- The content before title -->
        {#if expanded}
          <slot name=\\"icon-expanded\\">
            <SvelteWithColor />
          </slot>
          {:else}
          <slot name=\\"icon-fold\\">
            <Svelte />
          </slot>
        {/if}
      </div>
      <div class=\\"c-expansion--title text-3.5\\">
        <!-- Customize the title content -->
        <slot name=\\"title\\">
          {title}
        </slot>
      </div>
    </div>
    <div
      class={\`c-expansion--arrow \${expanded ? 'c-expansion--arrow-expanded' : ''} text-6 flex items-center\`}
    >
      <!-- Customize the arrow dom -->
      <slot name=\\"arrow\\">
        <ArrowDown />
      </slot>
    </div>
  </div>
  {#if !reverse && expanded}
    <div
      transition:slide
      bind:this={bodyDom}
      class=\\"c-expansion--body\\"
    >
      <!--  
        Expansion body content 
      -->
      <slot />
    </div>
  {/if}
</div>
",
    ],
    "version": 3,
  },
}
`;
